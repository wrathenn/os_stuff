## UNIX sockets

1. Как взаимодействуют сокеты AF_UNIX?
   >  Через файловое пространство имен

2. Что делают функции
   > socket() -- создает дескриптор сокета
   >
   > bind() -- связывает дескриптор сокета с адресом(файлом)
   >
   > recvfrom() -- получить информацию от клиента (можно без установления соединения)
   >
   > sentdo() -- отправить информацию клиенту

3. Почему не read/write?
   > В сигнатуре данных функций нет адреса, и они работают только с открытым соединением.
   > Мы соединение не создаем.

4. Показать сокеты
   > ls -ali

## INET sockets

1. Какой мультиплексор использовали?
    > pselect (последний аргумент NULL <=> select)

2. Какие аргументы передаёте мультиплексору? 
   >> int pselect(int nfds, *readfds, writefds, exceptfds, timeout, sigmask)
   > 
   > nfds -- максимальное значение дескриптора по всем множествам плюс единица
   > 
   > readfds -- дескрипторы сокетов, из которых требуется читать данные
   > 
   > writefds -- дескрипторы сокетов, в которые собираемся писать
   > 
   > exceptfds -- дескрипторы сокетов, которые нужно контролировать на возникновение ошибки
   > 
   > timeout -- величина таймаута
   > 
   > sigmask -- маска сигнала (какие сигналы будут блокироваться при обработке сигнала)

3. Почему мультиплексирование лучше чем ожидание отдельного сокета (примерная формулировка)?
   > Все соединения опрашиваются одновременно, сокращается время блокировки
   > 
   > Мультиплексор выбирает первый готовый сокет.
   > 
   > Преимущество -- ожидаем установки соединения не с конкретным сокетом, а выбираем сразу готовый.
   > 
   > Является аналогом многопоточной обработки

4. Что позволяет INADR_ANY(в сетевых)? 
   > Реализовать на отдельной машине работу распределённой системе.
   > 
   > Подключение к любому свободному айпи адресу


5. Показать, что сервер запущен
   > ss -tulp

6. Что делает accept()?
   > Устанавливает соединение в ответ на запрос клиента и создает копию сокета для того, чтобы исходный соект мог продолжать прослушиваание